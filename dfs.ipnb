
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "How to implement depth-first search in Python\n",
    "============================================="
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "[Depth-first search](https://www.educative.io/edpresso/what-is-depth-first-search) (DFS), is an algorithm for tree traversal on graph or tree data structures. It can be implemented easily using recursion and data structures like dictionaries and sets.\n",
    "\n",
    "The Algorithm\n",
    "-------------\n",
    "\n",
    "1.  Pick any node. If it is unvisited, mark it as visited and recur on all its adjacent nodes.\n",
    "2.  Repeat until all the nodes are visited, or the node to be searched is found.\n",
    "\n",
    "Implementation\n",
    "--------------\n",
    "\n",
    "Consider this graph, implemented in the code below:\n",
    "\n",
    "![svg viewer](https://www.educative.io/api/edpresso/shot/5410617873661952/image/6437799702036480)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "A\n",
      "B\n",
      "D\n",
      "E\n",
      "F\n",
      "C\n"
     ]
    }
   ],
   "source": [
    "# Using a Python dictionary to act as an adjacency list\n",
    "graph = {\n",
    "    'A' : ['B','C'],\n",
    "    'B' : ['D', 'E'],\n",
    "    'C' : ['F'],\n",
    "    'D' : [],\n",
    "    'E' : ['F'],\n",
    "    'F' : []\n",
    "}\n",
    "\n",
    "visited = set() # Set to keep track of visited nodes.\n",
    "\n",
    "def dfs(visited, graph, node):\n",
    "    if node not in visited:\n",
    "        print (node)\n",
    "        visited.add(node)\n",
    "        for neighbour in graph[node]:\n",
    "            dfs(visited, graph, neighbour)\n",
    "\n",
    "# Driver Code\n",
    "dfs(visited, graph, 'A')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Explanation\n",
    "-----------\n",
    "\n",
    "-   Lines 2-9: The illustrated graph is represented using an adjacency list - an easy way to do it in Python is to use a *dictionary* data structure. Each vertex has a list of its adjacent nodes stored.\n",
    "-   Line 11: `visited` is a set that is used to keep track of visited nodes.\n",
    "-   Line 21: The `dfs` function is called and is passed the `visited` set, the `graph` in the form of a dictionary, and `A`, which is the starting node.\n",
    "-   Lines 13-18: `dfs` follows the algorithm described above:\n",
    "    1.  It first checks if the current node is unvisited - if yes, it is appended in the `visited` set.\n",
    "    2.  Then for each neighbor of the current node, the `dfs` function is invoked again.\n",
    "    3.  The base case is invoked when all the nodes are visited. The function then returns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
